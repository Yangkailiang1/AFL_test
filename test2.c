#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <signal.h>

/*
  AFL 综合变异策略测试程序

  目标：覆盖 AFL 文档中描述的多种典型变异策略
  种子 1：64 字节的 0x00
  种子 2：64 字节的 0xFF（用于拼接 Splicing）
*/

typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;

int main(int argc, char** argv) {
    u8 buf[128];
    memset(buf, 0, sizeof(buf));
    
    // 从标准输入读取最多 100 字节
    int len = read(0, buf, 100);
    if (len < 64) return 0; // 至少需要 64 字节输入

    // =========================================================
    // 1. Walking Bit Flips（逐位翻转）
    // =========================================================
    
    // 策略：bitflip 1/1
    // 翻转第 0 字节的第 0 位：0x00 -> 0x01
    // 注意：该情况也可能由 arith +1 触发，但 AFL 会优先尝试 bitflip
    if (buf[0] == 0x01) {
        // 二次确认不是算术变异（其他字节仍为 0）
        if (buf[1] == 0) abort(); 
    }

    // 策略：bitflip 2/1（连续翻转 2 位）
    // 翻转第 1 字节的 bit 0–1：0x00 -> 0x03（0000 0011）
    // bitflip 1/1 只能产生 0x01 或 0x02，无法一次得到 0x03
    if (buf[1] == 0x03) {
        if (buf[0] == 0) abort();
    }

    // 策略：bitflip 4/1（连续翻转 4 位）
    // 翻转第 2 字节的 bit 0–3：0x00 -> 0x0F（0000 1111）
    if (buf[2] == 0x0F) {
        if (buf[0] == 0) abort();
    }

    // =========================================================
    // 2. Walking Byte Flips（按字节翻转）
    // =========================================================

    // 策略：bitflip 8/8（翻转一个字节的所有位）
    // 第 3 字节：0x00 -> 0xFF
    if (buf[3] == 0xFF) {
        if (buf[0] == 0) abort();
    }

    // 策略：bitflip 16/8（翻转 2 个字节）
    // 第 4–5 字节：0x0000 -> 0xFFFF
    // 使用 u16 类型解释
    if (*(u16*)(buf + 4) == 0xFFFF) {
        if (buf[0] == 0) abort();
    }

    // 策略：bitflip 32/8（翻转 4 个字节）
    // 第 6–9 字节：0x00000000 -> 0xFFFFFFFF
    if (*(u32*)(buf + 6) == 0xFFFFFFFF) {
        if (buf[0] == 0) abort();
    }

    // =========================================================
    // 3. Simple Arithmetics（简单算术变异）
    // =========================================================

    // 策略：arith 8/8
    // 第 10 字节：0x00 -> 0x0A（+10）
    // 避免使用 1、2 等小值（容易被 bitflip 捕获）
    if (buf[10] == 10) {
        // 确保不是 bitflip：
        // 10 = 0000 1010
        // 从 0x00 通过单 bitflip 只能得到 0x08 或 0x02
        if (buf[0] == 0) abort();
    }

    // 策略：arith 16/8
    // 第 12–13 字节：0x0000 -> 0x0100（256）
    // 该操作涉及进位，影响高字节
    // AFL 会对 16 位整数尝试加法
    // 在小端系统中：0x0000 + 256 = 0x0100 → 内存为 00 01
    // 因此检测 buf[12]=0x00 且 buf[13]=0x01
    if (buf[12] == 0x00 && buf[13] == 0x01) {
        if (buf[0] == 0) abort();
    }

    // 策略：arith 32/8
    // 第 16–19 字节：0x00000000
    // 目标值：0x00010000（65536）
    // 小端表示：00 00 01 00
    if (buf[16] == 0x00 && buf[17] == 0x00 && buf[18] == 0x01 && buf[19] == 0x00) {
        if (buf[0] == 0) abort();
    }

    // =========================================================
    // 4. Known Integers（Interest 特殊整数）
    // =========================================================

    // 策略：interest 8/8
    // 第 20 字节
    // 有趣值包括：-128、-1、0、1、16、32、64、100、127 等
    // 0x80 可以被 bitflip 1/1 命中，因此选择 0x7F（127）
    if (buf[20] == 0x7F) {
        if (buf[0] == 0) abort();
    }

    // 策略：interest 16/8
    // 第 22–23 字节
    // 0xFFFF 已被 bitflip 覆盖
    // 选择 -2（0xFFFE），从 0x0000 需要翻转 15 位
    if (*(u16*)(buf + 22) == 0xFFFE) {
        if (buf[0] == 0) abort();
    }

    // 策略：interest 32/8
    // 第 26–29 字节
    // 选择 MAX_INT：0x7FFFFFFF
    // 从 0x00000000 需要翻转 31 位
    if (*(u32*)(buf + 26) == 0x7FFFFFFF) {
        if (buf[0] == 0) abort();
    }

    // =========================================================
    // 5. Stacked Tweaks（Havoc）与 Splicing（拼接）
    // =========================================================

    // Havoc：多字节随机修改
    // 检测字符串 "HVC"
    // 从全 0 变为 "HVC" 的概率较低，但 Havoc 允许直接覆盖
    if (buf[30] == 'H' && buf[31] == 'V' && buf[32] == 'C') {
        if (buf[0] == 0) abort();
    }

    // Splicing（拼接）
    // 使用全 0 种子和全 0xFF 种子进行拼接
    // 查找明显的拼接边界
    // buf[40..43] == 0x00 且 buf[44..47] == 0xFF
    if (*(u32*)(buf + 40) == 0x00000000 && *(u32*)(buf + 44) == 0xFFFFFFFF) {
        // 表明拼接点大约在第 44 字节
        abort();
    }

    // =========================================================
    // 6. Dictionary（用户自定义字典）
    // =========================================================

    // 策略：user extras（覆盖 / 插入）
    // 在字典中提供字符串 "ABCD"
    // 目标位置：第 50 字节
    if (buf[50] == 'A' && buf[51] == 'B' && buf[52] == 'C' && buf[53] == 'D') {
        if (buf[0] == 0) abort();
    }

    return 0;
}
